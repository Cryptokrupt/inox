functional:
  title: Functional Programming
  elements:
  - topic: map
    related-topics: [filter, get_at_most, some, all, none]
    text: The map function creates a list by applying an operation on each element of an iterable
    examples:
    - code: 'map([{name: "foo"}], .name)'
      output: '["foo"]'
      standalone: true

    - code: 'map([{a: 1, b: 2, c: 3}], .{a,b})'
      output: '[{a: 1, b: 2}]'
      standalone: true

    - code: 'map([0, 1, 2], Mapping{0 => "0" 1 => "1"})'
      output: '["0", "1", nil]'
      standalone: true

    - code: 'map([97, 98, 99], torune)'
      output: "['a', 'b', 'c']"
      standalone: true

    - code: 'map([0, 1, 2], @($ + 1))'
      output: '[1, 2, 3]'
      standalone: true

  - topic: filter
    related-topics: [map, get_at_most, some, all, none]
    text: The filter function creates a list by iterating over an iterable and keeping elements that pass a condition
    examples:
    - code: 'filter(["a", "0", 1], %int)'
      output: '[1]'
      standalone: true

    - code: 'filter([0, 1, 2], @($ >= 1))'
      output: '[1, 2]'
      standalone: true

  - topic: get_at_most
    related-topics: [filter, map, some, all, none]
    text: The get_at_most function gets at most the specified number of elements from an iterable
    examples:
    - code: 'get_at_most(1, [])'
      output: '[]'
      standalone: true

    - code: 'get_at_most(3, ["a", "b"])'
      output: '["a", "b"]'
      standalone: true

    - code: 'get_at_most(2, ["a", "b", "c"])'
      output: '["a", "b"]'
      standalone: true

  - topic: some
    related-topics: [map, filter, all, none]
    text: The some function returns true if and only if at least one element of an iterable passes a condition. For an empty iterable the result is always true.
    examples:
    - code: 'some(["a", "0", 1], %int)'
      output: 'true'
      standalone: true

    - code: "some([0, 1, 2], @($ == 'a'))"
      output: 'false'
      standalone: true

  - topic: all
    related-topics: [map, filter, some, none]
    text: The all function returns true if and only if all elements of an iterable pass a condition. For an empty iterable the result is always true.
    examples:
    - code: 'all([0, 1, "a"], %int)'
      output: 'false'
      standalone: true

    - code: 'all([0, 1, 2], @($ >= 0))'
      output: 'true'
      standalone: true
      
  - topic: none
    related-topics: [map, filter, some, all]
    text: The none function returns true if and only if no elements of an iterable pass a condition. For an empty iterable the result is always true.
    examples:
    - code: 'none([0, 1, "a"], %int)'
      output: 'false'
      standalone: true

    - code: 'none([0, 1, 2], @($ < 0))'
      output: 'true'
      standalone: true

  - topic: sort
    text: >
      The sort function creates a new list by sorting a list of strings or integers, the second argument is an identifier describing
      the order. For strings the available orderings are `#lex` (lexicographic) and `#revlex` (same but reversed). For integers the available
      orderings are `#asc` (ascending) and `#desc` (descending).
    examples:
    - code: 'sort([2, 1], #asc)'
      output: '[1, 2]'
      standalone: true

    - code: 'sort(["b", "a"], #lex)'
      output: '["a", "b"]'
      standalone: true

  - topic: find
    text: The find function searches for items matching a pattern at a given location (a string, an iterable, a directory)
    examples:
    - code: 'find %`a+` "a-aa-aaa"'
      output: '["a", "aa", "aaa"]'
      standalone: true

    - code: 'find %./**/*.json ./'
      output: '[./file.json, ./dir/file.json, ./dir/dir/.file.json]'

    - code: find %int ['1', 2, "3"]
      output: '[2]'
      standalone: true
  
  - topic: idt
    text: The idt (identity) function takes a single argument and returns it.

rand:
  elements:
  - topic: rand
    related-topics: [pseudo_rand]
    text: >
      The rand function generates/picks a random value in a cryptographically secure way.
      If the argument is a pattern a matching value is returned, if the argument is an indexable an element is picked.
    examples:
    - code: 'rand(%int(0..10))'
      output: '3'
      standalone: true

    - code: 'rand(%str("a"+))'
      output: '"aaaaa"'
      standalone: true

    - code: 'rand(["a", "b"])'
      output: '"b"'
      standalone: true

crypto:
  title: Cryptography
  elements:
  - topic: hash_password
    text: >
      The hash_password function hashes a password string using the Argon2id algorithm, it returns a string
      containing: the hash, a random salt and parameters. You can find the implementation in this file: https://github.com/inoxlang/inox/blob/main/internal/globals/crypto.go 
    examples:
    - code: 'hash_password("password")'
      output: '$argon2id$v=19$m=65536,t=1,p=1$xDLqbPJUrCURnSiVYuy/Qg$OhEJCObGgJ2EbcH0a7oE2sfD1+5T2BPRs8SRWkreE00'
      standalone: true

  - topic: check_password
    text: The check_password verifies that a password matches a Argon2id hash.
    related-topics: [hash_password]
    examples:
    - code: 'check_password("password", "$argon2id$v=19$m=65536,t=1,p=1$xDLqbPJUrCURnSiVYuy/Qg$OhEJCObGgJ2EbcH0a7oE2sfD1+5T2BPRs8SRWkreE00")'
      output: 'true'
      standalone: true

  - topic: sha256
    text: The sha256 function hashes a string or a byte sequence with the SHA-256 algorithm
    examples:
    - code: sha256("string")
      output: '0x[473287f8298dba7163a897908958f7c0eae733e25d2e027992ea2edc9bed2fa8]'
      standalone: true

  - topic: sha384
    text: The sha384 function hashes a string or a byte sequence with the SHA-384 algorithm
    examples:
    - code: sha384("string")
      output: '0x[36396a7e4de3fa1c2156ad291350adf507d11a8f8be8b124a028c5db40785803ca35a7fc97a6748d85b253babab7953e]'
      standalone: true

  - topic: sha512
    text: The sha512 function hashes a string or a byte sequence with the SHA-512 algorithm
    examples:
    - code: sha512("string")
      output: '0x[2757cb3cafc39af451abb2697be79b4ab61d63d74d85b0418629de8c26811b529f3f3780d0150063ff55a2beee74c4ec102a2a2731a1f1f7f10d473ad18a6a87]'
      standalone: true

  - topic: rsa
    namespace: true
    text: The rsa namespace contains functions to generate a key pair and encrypt/decrypt using OAEP.
    subtopics:
    - topic: rsa.gen_key
      text: The rsa.gen_key function generates a public/private key pair
      examples:
      - code: 'rsa.gen_key()'
        output: '#{public: "<key>", private: "<secret key>"}'
        standalone: true

    - topic: rsa.encrypt_oaep
      text: The rsa.encrypt_oaep function encrypts a string or byte sequence using a public key
      examples:
      - code: 'rsa.encrypt_oaep("message", public_key)'

    - topic: rsa.decrypt_oaep
      text: The rsa.decrypt_oaep function decrypts a string or byte sequence using a private key
      examples:
      - code: 'rsa.encrypt_oaep(bytes, private_key)'

encoding:
  title: Encodings
  elements:
  - topic: b64
    text: The b64 function encodes a string or byte sequence to Base64.

  - topic: db64
    text: The db64 function decodes a byte sequence from Base64.

  - topic: hex
    text: The hex function encodes a string or byte sequence to hexadecimal.

  - topic: unhex
    text: The unhex function decodes a byte sequence from hexadecimal.

conversion:
  title: Conversion
  elements:
  - topic: tostr
    text: > 
      The tostr function converts its argument to a string. Only the following types
      are supported: bool, int, str, byte-slice, rune-slice, path, host, url.

  - topic: torune
    text: The torune function converts an integral value to a rune.

  - topic: tobyte
    text: The tobyte function converts an integer to a byte.

  - topic: tofloat
    text: The tofloat function converts an integer to a float.

  - topic: toint
    text: The toint function converts a float or byte to an integer. An error is thrown if precision has been lost.

  - topic: tobytecount
    text: The tobytecount function converts an integer to a byte count. An error is thrown if the provided value is negative.

  - topic: torstream
    text: >
      The torstream function creates a readable stream from a value. If the value is readable (string, byte-slice, ...)
      a byte stream is returned. If the value is indexable a stream containing the elements is returned.
      
  - topic: tojson
    text: The tojson function converts a value to JSON (string).

  - topic: topjson
    text: The topjson function converts a value to formatted JSON (string).

  - topic: torepr
    text: The torepr function converts a value to its IXON representation (Inox Object Notation).

  - topic: parse_repr
    text: The parse_repr function parses an IXON string and returns the unmarshalled value.

  - topic: parse
    text: The parse function parses a string based on the specified pattern.
    examples:
    - code: 'parse!("1", %int)'

  - topic: split
    text: The split function slices a string into all substrings separated by sep. If a pattern is 
      given as a second argument each substring is parsed based on it.
    examples:
    - code: 'split!("a,b", ",")'
      explanation: 'returns ["a", "b"]'
    - code: 'split!("1,2", ",", %int)'
      explanation: 'returns [1, 2]'
    - code: 'split!("first line\nsecond line", "\n")'
      explanation: 'returns ["first line", "second line"]'


time:
  title: Time
  elements:
  - topic: ago
    text: The ago function returns the current datetime minus the provided duration.
    examples:
    - code: 'ago(1h)'
      standalone: true

  - topic: now
    text: The now function returns the current datetime.

  - topic: time_since
    text: The time_since function returns the time elapsed (duration) since the provided datetime. 

  - topic: sleep
    text: The sleep function pauses the execution for the given duration.
    examples:
    - code: 'sleep(1s)'
      standalone: true

printing:
  title: Printing
  elements:
  - topic: print
    text: "The print function prints its arguments with a space ' ' separation. A `\\n` character is added at the end."

  - topic: fprint
    text: "The fprint function writes to the provided writer its arguments with a space ' ' separation. A '\\n' character is added at the end."

log:
  namespace: true
  title: Structured Logging
  elements:
  - topic: log
    text: The log namespace contains functions for structured logging.
  - topic: log.add
    text: >
      The log.add function logs an event that is created from the provided record. The log level is specified with the `lvl` property,
      it defaults to `debug`. The message can be either provided by setting the `msg` property or by adding properties with implicit keys:
      each implicit-key property will be a single part of the message. ⚠️ It is recommended to use the default level (debug) for high frequency events.
    examples:
    - code: |
        # add a log event of level 'debug' with the message 'user created'
        log.add #{"user created"}
      standalone: true

    - code: |
        # add a log event of level 'debug' with the message 'user created'
        log.add #{msg: "user created"}
      standalone: true

    - code: |
        # add a log event of level 'info' with the message 'user created'
        log.add #{lvl: "info", msg: "user created"}
      standalone: true

    - code: |
        id = 100
        # add a log event of level 'debug' with the message 'user 100 created'
        # and a field `id: 100`
        log.add #{"user", id, "created", id: 100}
      standalone: true

bytes-runes:
  title: Bytes and Runes
  elements:
  - topic: mkbytes
    text: The mkbytes function allocates a byte-slice of the provided size.
    examples:
    - code: 'mkbytes(1kB)'
      standalone: true

  - topic: Bytes
    text: The Bytes function reads a readable (string, byte-slice, ...) and returns a byte-slice.
    examples:
    - code: 'bytes = Bytes("abc")'
      standalone: true

  - topic: Runes
    text: >
      The Runes function reads a readable (string, byte-slice, ...) and returns a rune-slice. A rune is a Unicode code point (character).
      See https://go.dev/blog/strings for more details.
    examples:
    - code: 'runes = Runes("abc")'

  - topic: is_space
    text: The is_space function returns whether a given rune is a space character (Unicode's White Space property).
    examples:
    - code: "is_space(' ') # true"
      standalone: true

  - topic: Reader
    text: The Reader function creates a reader from a readable (string, byte-slice, ...).
    examples:
    - code: |
        reader = Reader("abc")
        bytes = reader.read_all!()

        # abc
        print(tostr(bytes))
      standalone: true

  - topic: RingBuffer
    text: The RingBuffer function creates a ring-buffer with a given capacity.
    examples: 
    - code: |
        buffer = RingBuffer(100B)
        buffer.write!("abc")

        # allocate a byte-slice to read from the buffer.
        buf = mkbytes(100B)

        # The read method writes to buf and returns the written slice of buf.
        # Make sure to not modify the returned slice since doing so would mutate buf.
        slice = buffer.read!(buf)

        # abc
        s = tostr(slice)
      standalone: true

html:
  namespace: true
  title: HTML
  elements:
  - topic: html
    text: The html namespace contains functions to create & manipulate HTML nodes
  - topic: html.find
    text: The html.find function finds all elements matching the specified CSS selector in the specified element.
    examples:
    - code: h1_elems = html.find("h1", html<div> <h1>title</h1> </div>)
  - topic: html.escape
    text: >
      The html.escape function escapes special characters like "<" to become "&lt;".
      It escapes only five such characters: <, >, &, ' and ".
    examples:
    - code: html.escape("<span></span>")
      output: "&lt;span&gt;&lt;/span&gt;"
      standalone: true

  - topic: html.Node
    text: >
      The html.Node factory function creates a node with a given tag. The first argument is the tag name. The second
      argument is an object with several optional parameters (properties): id, class, children. Additional parameters
      depend on the tag: (e.g. href for `<a>`). html.Node is still being developped, for now it only supports additional 
      parameters for `<a>`. It is recommended to use XML expressions with `html` as the namespace instead of using html.Node: 
      calling the function and creating the object argument (description) is not efficient.
    examples:
    - code: html.Node("a", {})
      output: "<a></a>"
      standalone: true

    - code: 'html.Node("a", {id: "link"})'
      output: '<a id="link"></a>'
      standalone: true

    - code: 'html.Node("a", {href: /index.html})'
      output: '<a href="/index.html"></a>'
      standalone: true
      
    - code: 'html.Node("div", {  html<span>text</span> })'
      output: '<div><span>text</span></div>'
      standalone: true

    - code: 'html.Node("div", { children: [ html<span>text</span> ] })'
      output: '<div><span>text</span></div>'
      standalone: true

chrome:
  namespace: true
  title: Browser Automation
  elements:
  - topic: chrome
    related-topics: [chrome.Handle]
    text: chrome namespace

  - topic: chrome.Handle
    text: |
      The Handle function creates a new Chrome handle that provides methods to interact with a web browser instance.
      You should call its .close() method when you are finished using it. 
      
      The project server downloads a Chromium browser
      if none is present. The list of checked paths can be found here: https://github.com/inoxlang/inox/blob/main/internal/globals/chrome_ns/download.go#L114C1-L114C43.
      If you are not using the project server you have to install Chrome or Chromium.

      The browser instance always forwards the HTTP requests to a local proxy server that runs inside an Inox process.
      Therefore make sure to add the necessary HTTP permissions in the manifest.
    examples:
    - code: 'chrome.Handle!()'
    subtopic-names: [
      chrome.Handle/nav, chrome.Handle/wait_visible, chrome.Handle/click, chrome.Handle/screenshot, 
      chrome.Handle/screenshot_page, chrome.Handle/html_node, chrome.Handle/close
    ]

  - topic: chrome.Handle/nav
    text: >
      The nav method makes the browser navigate to a page. All HTTP requests made by the browser are checked against the permission system,
      so make sure to add the necessary permissions.
    examples:
    - code: 'handle.nav https://go.dev/'

  - topic: chrome.Handle/wait_visible
    text: The wait_visible method waits until the DOM element matching the selector is visible.
    examples:
    - code: 'handle.wait_visible "div.title"'


  - topic: chrome.Handle/click
    text: The click method makes the browser click on the first DOM element matching the selector.
    examples:
    - code: 'handle.click "button.menu-item"'

  - topic: chrome.Handle/screenshot
    text: The screenshot method takes a screenshot of the first DOM element matching the selector.
    examples:
    - code: 'png_bytes = handle.screenshot!("#content")'

  - topic: chrome.Handle/screenshot_page
    text: The screenshot_page method takes a screenshot of the entire browser viewport.
    examples:
    - code: 'png_bytes = handle.screenshot_page!()'

  - topic: chrome.Handle/html_node
    text: The screenshot method gets the HTML of the first DOM element matching the selector, the result is %html.node not a string.
    examples:
    - code: 'png_bytes = handle.screenshot_page!()'

  - topic: chrome.Handle/close
    text: this method should be called when you are finished using the Chrome handle.

containers:
  title: Data Containers
  elements:
  - topic: Graph
    related-topics: [Tree]
    text: The Graph function creates a directed Graph

  - topic: Tree
    related-topics: [Graph]
    text: The Tree function creates a tree from a treedata value
    examples:
    - code: 'Tree(treedata "root")'
      explanation: creates a Tree with a single node
      standalone: true

  - topic: Stack
    text:  "the Stack function creates a stack from an iterable"
    examples:
    - code: 'Stack([])'
      explanation: creates an empty stack
      standalone: true

    - code: 'Stack([1])'
      explanation: "creates a stack with an element 1"
      standalone: true

  - topic: Queue
    text: The Queue function creates a queue from an iterable
    examples:
    - code: 'Queue([])'
      explanation: creates an empty queue
      standalone: true

    - code: 'Queue([1])'
      explanation: creates a queue with an element 1
      standalone: true

  - topic: Set
    text: >
      The Set function creates a set from an iterable, by default only representable (serializable) values are allowed.
      A configuration is accepted as a second argument.

    examples:
    - code: 'Set([])'
      explanation: creates an empty set
      standalone: true

    - code: 'Set([1])'
      explanation: "creates a queue with an element 1"
      standalone: true

    - code: 'Set([], {element: %int})'
      explanation: creates an empty set of integers
      standalone: true

    - code: 'Set([{name: "A"}, {name: "B"}], {uniqueness: .name})'
      explanation: creates a set of values where the identity is defined by the .name property
      standalone: true

  - topic: Map
    text: The Map function creates a map from a flat list of entries
    examples:
    - code: 'Map(["key1", 10, "key2", 20])'
      explanation: creates a Map with the entries "key1" -> 10, "key2" -> 20`
      standalone: true

  - topic: Ranking
    text: >
      The Ranking function creates a ranking from a flat list of entries.
      An entry is composed of a value and a floating-point score. 
      The value with the highest score has the first rank (0), values with the same score have the same rank.
    examples:
    - code: 'Ranking(["best player", 10.0, "other player", 5.0])'
      explanation: 'creates a Ranking with the following ranks: rank(0) -> "best player", rank(1) -> "other player"'
      standalone: true

    - code: 'Ranking(["best player", 10.0, "other player", 10.0])'
      explanation: 'creates a Ranking with the following ranks: rank(0) -> "best player" & "other player"'
      standalone: true
      
  - topic: Thread
    text: The Thread function creates a thread from an iterable.
    examples:
    - code: 'Thread([{message: "hello", author-id: "5958"}])'
      standalone: true


dns:
  namespace: true
  title: DNS
  elements:
  - topic: dns.resolve
    text: The dns.resolve function retrieves DNS records of the given type.
    examples:
    - code: 'dns.resolve!("github.com" "A")'
      explanation: retrieves "A" records for github.com
      standalone: true

tcp:
  namespace: true
  title: TCP
  elements:
  - topic: tcp.connect
    text: The tcp.connect function creates a TCP connection to a given host.
    examples:
    - code: |
        conn = tcp.connect!(://example.com:80)

        conn.write!("GET / HTTP/1.1\nHost: example.com\n\n")
        print tostr(conn.read!())

        conn.close()
      standalone: true

resource:
  namespace: false
  title: Resource Manipulation
  elements:
  - topic: read
    text: > 
      read is a general purpose function that reads the content of a file, a directory or an HTTP resource.
      The content is parsed by default, to disable parsing use --raw after the resource's name: a byte slice 
      will be returned instead. The type of content is determined by looking at the extension for files & 
      the Content-Type header for HTTP resources.
    examples:
      - code: 'read ./'
        output: |
          [
            dir/
            file.txt 1kB 
          ]
        explanation: returns a list containing the entries of the directory ./

      - code: 'read ./file.txt'
        output: hello

      - code: 'read ./file.json'
        output: '{"key": "value"}'

      - code: 'read https://jsonplaceholder.typicode.com/posts/1'
        output: |
          {
            "body": "quia et suscipit\nsuscipit recusandae consequuntur expedita....", 
            "id": 1.0, 
            "title": "sunt aut facere repellat provident occaecati excepturi optio reprehenderit", 
            "userId": 1.0
          }
  - topic: create
    text: create is a general purpose function that can create a file, a directory or an HTTP resource.
    examples:
    - code: 'create ./dir/'
    - code: 'create ./empty-file.txt'
    - code: 'create ./file.txt "content"'

  - topic: update
    text: >
      update is a general purpose function that updates an existing resource, it has 2 modes: append and replace.
      Replace is the default mode.
    examples:
    - code: 'update ./file.txt append "additional content"'
    - code: update ./file.txt "new content"
    - code: update ./file.txt replace "new content"
    - code: 'update https://example.com/users/100 tojson({name: "foo"})'

  - topic: delete
    text: 'delete is a general purpose function that deletes a resource, deletion is recursive for directories.'
    examples:
    - code: 'delete ./file.txt'
    - code: 'delete ./dir/'
    - code: 'delete https://example.com/users/100'

fs:
  namespace: true
  title: Filesystem
  elements:
  - topic: fs
    text: The fs namespace contains functions to interact with the filesystem.

  - topic: fs.mkfile
    text: >
      The fs.mkfile function takes a file path as first argument. It accepts a --readonly switch that causes 
      the created file to not have the write permission ; and a %readable argument that is the content of the file to create.
    examples:
    - code: fs.mkfile ./file.txt
    - code: fs.mkfile ./file.txt "content"

  - topic: fs.mkdir
    text: The fs.mkdir function takes a directory path as first argument & and optional dictionary literal as a second argument.
      The second argument recursively describes the content of the directory.
    examples:
    - code: fs.mkdir ./dir_a/
    - code: |
        dir_content = :{
            ./subdir_1/: [./empty_file]
            ./subdir_2/: :{  
                ./file: "foo"
            }
            ./file: "bar"
        }

        fs.mkdir ./dir_b/ $dir_content

  - topic: fs.read
    text: > 
      The fs.read function behaves exactly like the read function but only works on files & directories.
      The content of files is parsed by default, to disable parsing use --raw after the path: a byte slice will be returned instead. 
      The type of content is determined by looking at the extension.

  - topic: fs.read_file
    text: >
      The fs.read function behaves exactly like the read function but only works on files.
      The content is parsed by default, to disable parsing use --raw after the path: a
      byte slice will be returned instead. The type of content is determined by
      looking at the extension.

  - topic: fs.ls
    text: >
      The fs.ls function takes a directory path or a path pattern as first argument and returns a list of entries, if no argument is provided
      the ./ directory is used.
    examples:
    - code: 'fs.ls()'
    - code: 'fs.ls ./'
    - code: 'fs.ls %./*.json'

  - topic: fs.rename
    alias: fs.mv
    text: >
      The fs.rename (fs.mv) function renames a file, it takes two path arguments. 
      An error is returned if a file already exists at the target path.

  - topic: fs.cp
    text: >
      The fs.cp function copies a file/dir at a destination or a list of files in a destination directory, the copy is recursive by default.
      As you can see this behaviour is not exactly the same as the cp command on Unix.
      An error is returned if a file or a directory already exists at one of the target paths (recursive).
    examples:
    - code: 'fs.cp ./file.txt ./file_copy.txt'
    - code: 'fs.cp ./dir/ ./dir_copy/'
    - code: 'fs.cp [./file.txt, ./dir/] ./dest_dir/'
      explanation: 'creates ./dest_dir/file.txt and ./dest_dir/dir/ by copying the provided file & directory'

  - topic: fs.exists
    text: 'the fs.exists takes a path as first argument and returns a boolean'

  - topic: fs.isdir
    text: 'the fs.isdir function returns true if there is a directory at the given path'

  - topic: fs.isfile
    text: 'the fs.isfile returns true if there is a regular file at the given path'

  - topic: fs.remove
    alias: fs.rm
    text: 'the fs.remove function removes a file or a directory recursively'

  - topic: fs.glob
    text: 'the fs.glob function takes a globbing path pattern argument (%./a/... will not work) and returns a list of paths matching this pattern.'
    example:
    - code: 'fs.glob %./*.json'
      explanation: 'returns paths of JSON files in the current directory.'

  - topic: fs.find
    text: >
      The fs.find function takes a directory path argument followed by one or more globbing path patterns, 
      it returns a directory entry for each file matching at least one of the pattern.

    examples:
    - code: 'fs.find ./ %./**/*.json'

  - topic: fs.get_tree_data
    text: > 
      The fs.get_tree_data function takes a directory path argument and returns a %treedata value 
      thats contains the file hiearachy of the passed directory.
    examples:
    - code: fs.get_tree_data(./)

http:
  namespace: true
  title: HTTP
  elements:
  - topic: http
    text: >
      The http namespace contains functions to read, modify & delete HTTP resources.
      Most functions accept the --insecure option to ignore certificate errors & the --client option
      to specify an HTTP client to use.
  - topic: http.get
    text: >
      The http.get function takes a URL (or host) as first argument and returns an HTTP response.
      The --insecure options causes the function to ignore certificate errors.
    examples:
    - code: 'http.get https://example.com/'

  - topic: http.read
    text: >
      The http.read function behaves exactly like the read function but only works on HTTP resources.
      By default the type of content is determined by looking at the Content-Type header. You can specify a content type
      by adding a mimetype value such as mime"json".
    examples:
    - code: 'http.read https://jsonplaceholder.typicode.com/posts/1'

  - topic: http.exists
    text: 'the http.exists takes a URL (or host) as argument, it sends a HEAD request and returns true if the status code is less than 400.'
  - topic: http.post
    text: > 
      The http.post sends a POST request to the specified URL (or host) with the given body value, the body value can be any %readable or serializable object/list.
      A %mimetype value can be specified to change the value of the Content-Type header.
    examples:
    - code: http.post https://example.com/posts `{"title":"hello"}`
    - code: 'http.post https://example.com/posts {title: "hello"}'
    - code: 'http.post https://example.com/posts [ {title: "hello"} ]'
    - code: 'http.post https://example.com/posts mime"json" {title:"hello"}'


  - topic: http.patch
    text: The http.patch function works like http.post but sends an HTTP PATCH request instead
    related-topics: [http.post]

  - topic: http.delete
    text: The http.delete function sends an HTTP DELETE request to the specified URL

  - topic: http.Client
    text: The http.Client function creates an HTTP client that can be used in most http.* functions with the --client flag.

    examples:
    - code: 'http.Client{ save-cookies: true }'
      explanation: saves the cookies received in responses, cookies are not persisted
      standalone: true

    - code: 'http.Client{ insecure: true }'
      explanation: ignore certificate errors
      standalone: true

    - code: |
        http.Client{
          request-finalization: :{
            https://example.com : { 
              add-headers: {X-API-KEY: env.initial.API_KEY}
            }
          } 
        }
      explanation: add X-API-KEY header to all requests sent to https://example.com
      standalone: true

  - topic: http.Server
    text: >
      The http.Server function creates a listening HTTP server with a given with a given address & handler. The address should be a HTTPS
      host such as `https://localhost:8080` or `https://0.0.0.0:8080`. The handler can be an function or a Mapping that routes requests. 
      When you send a request to a server listening on localhost add the --insecure flag to ignore certificate errors. When using filesystem routing modules are reloaded each time files are changed in /routes/.
      Also for each page render a nonce is added to the `script-src-elem` CSP directive and to all `<script>` elements in the page's HTML.
    examples:
    - code: |
        server = http.Server!(https://localhost:8080, {
            routing: {
                static: /static/
                dynamic: /routes/
            }
        })
      explanation: >
         creates an HTTP server at https://localhost:8080 with filesystem routing. The server will look for static files in the /static/ folder
         and dynamic handler modules (.ix files) in the /routes/ folder. Modules are reloaded each time files are changed in /routes/.
         To learn about filesystem routing see https://github.com/inoxlang/inox/blob/main/docs/web-app-development.md#2-filesystem-routing
      standalone: true

    - code: |
        fn handle(rw http.resp-writer, r http.req){
          rw.write_json({ a: 1 })
        }

        server = http.Server!(https://localhost:8080, Mapping {
            /hello => "hello"
            %/... => handle
        })
      explanation: >
        creates an HTTP server at https://localhost:8080, requests to /hello will return 'hello' & other requests will
        be handled by the 'handle' function.
      standalone: true

    - code: |
        fn handle(rw http.resp-writer, r http.req){
            match r.path {
              / {
                  rw.write_json({ a: 1 })
              }
              %/... {
                rw.write_headers(404)
              }
            }
        }

        server = http.Server!(https://localhost:8080, handle)
      explanation: >
        creates an HTTP server at https://localhost:8080 that returns a JSON body with {a: 1} for the '/' path 
        and a 404 status for other paths.
      standalone: true

  - topic: http.FileServer
    text: The http.FileServer creates an HTTP server that serves static file from a given directory.
    examples:
    - code: http.FileServer!(https://localhost:8080, ./examples/static/)
      explanation: https://localhost:8080/index.html will return the content of the file ./examples/static/index.html

  - topic: http.servefile

  - topic: http.CSP
    text: |
      The http.CSP function creates a Content Security Policy with the passed directives and some default directives: 
      all directive types that are not provided in arguments default to the following directives:
        - `default-src 'none';`
        - `frame-ancestors 'none';`
        - `frame-src 'none';`
        - `script-src-elem 'self' 'nonce-[page-nonce]>';`
        - `connect-src 'self';`
        - `font-src 'self';`
        - `img-src 'self';`
        - `style-src-elem 'self' 'unsafe-inline';`
    examples:
    - code: "http.CSP{default-src: \"'self'\"}"
      standalone: true

Errors:
  namespace: false
  elements:
  - topic: Error
    text: The Error function creates an error from the provided string and an optional immutable data argument.
    examples:
    - code: 'Error("failed to create user")'
      standalone: true

    - code: 'Error("failed to create user", #{user_id: 100})'
      standalone: true
