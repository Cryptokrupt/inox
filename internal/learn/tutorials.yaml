# tutorial series

- name: Basics  
  id: basics
  description: >
    Learn the basics of Inox in a few tutorials !
  
  tutorials:
  - name: Hello World
    id: hello-world
    program: |
      # Inox modules always start with a manifest.
      manifest { }
      
      print("Hello World!")
    output: 
    - Hello World!
  - name: Variables
    id: var-basics
    program: |
      manifest {}
      
      # There are two kinds of variables: globals & locals.
      # Local variables are declared with the `var` keyword or with an assignment.
      var local1 = 1
      
      # Assigning a local that is not declared is equivalent to declaring it.
      local2 = 2
      
      # Variable declarations can have a type annotation.
      # Replace `0` with `str` to see what happens.
      var i int = 0

      # Global variable declaration
      globalvar global1 = 1

      # Assigning a global that is not declared is equivalent to declaring it.
      $$global2 = 2
      
      # Global variables cannot be shadowed by local variables.
      # var global1 = 3

      print("local1 =", local1, "global1 =", global1)
    output:
    - "local1 = 1 global1 = 1"

  - name: Functions
    id: func-basics
    program: |
      manifest {}
      
      # Native (Golang) functions are built-in and cannot be defined.
      print("print is a native function")

      # Inox Functions are declared at the top-level of the module.
      fn hello(arg){
          print("hello", arg)
          return 0
      }

      # Parameters and return value of a function can have a type annotation:
      fn add(a int, b int) int {
          return (a + b)
      }

      # Parenthesized call
      print("add(1, 2) =", add(1, 2))

      pattern user = {
          name: str
          friends: []str
      }

      fn new_user(data {name: str}) user {
          return {
              name: data.name
              friends: []
          }
      }

      # Shorthand call syntax for functions accepting a single argument of type object.
      user = new_user{name: "Tom"}
    output:
    - "print is a native function"
    - "add(1, 2) = 3"

  - name: "'Must' calls"
    id: must-call-basics
    program: |
      manifest {}

      # 'must' calls are special calls that cause a panic if there is an error. 
      # If there is no error the returned value is transformed.

      # the unhex function decodes an hexadecimal strig.
      # normal call: a value of type Array(byte-slice, (error | nil)) is returned.
      assign bytes error = unhex("...")

      print("decoding error:", error)

      # must call: a value of type byte-slice is returned if there is no error.
      # bytes = unhex!("...")

      fn f(issue bool) (| error | nil) {
          if issue {
              return Error("there is an issue !")
          }
          return nil
      }

      # normal call: a value of type (error | nil) is returned.
      err = f(true)

      print("error returned by `f`:", err)

      # must call: on error the runtime panics, otherwise nil is returned.
      nil_value = f!(false)      

      # you can learn more about must calls here: https://github.com/inoxlang/inox/blob/master/docs/language-reference.md#must-calls.
    output:
    - "decoding error: (hex.InvalidByteError)encoding/hex: invalid byte: U+002E '.'"
    - "error returned by `f`: (*errors.errorString)there is an issue !"

  - name: Binary expressions
    id: bin-expr-basics
    program: |
      manifest {}

      # Binary operations are always parenthesized:

      int = (1 + 2)
      float = (1.0 + (5.0 + 2.0))
      range1 = (0 .. 2)   # inclusive end
      range2 = (0 ..< 3)  # exclusive end

      # Parentheses can be omitted around operands of or/and chains:

      a = true; b = false; c = true
      n = 0; p = 2

      (a or b or c)      
      (n < 1 or p < 3)

      # 'or' and 'and' cannot be mixed in the same chain
      # (a or b and c)     

    output: []


  - name: If, Switch, Match
    id: if-switch-match-basics
    program: |
      manifest {}

      a = 0

      # if statement
      if (a == 0) {
          print("a == 0")
      } else {
          print("a != 0")
      }

      # if expression
      zero = (if (a == 0) 0 else 1)

      b = 1

      # switch statement
      switch b {
          0 {
              print("b == 0")
          }
          1 {
              print("b == 1")
          }
          defaultcase {
              print("b != 0 and b != 1")
          }
      }

      # The match statement is similar to the switch statement but uses patterns as case values. 
      # It executes the block following the first pattern matching the value.

      c = 2

      match c {
          %int(0..2) {
              print "c is in the range 0..2"
          }
          %int {
              print "c is an integer"
          }
          defaultcase { 
              print "c is not an integer"
          }
      }
    output:
    - "a == 0"
    - "b == 1"
    - "c is in the range 0..2"

  - name: For statement
    id: for-stmt-basics
    program: |
      manifest {}

      list = ["a", "b", "c"]

      for elem in list {
          print(elem)
      }

      print()

      for index, elem in list {
          print(index, elem)
      }

      print()

      for i in (0 ..< len(list)) {
          print(i, list[i])
      }

      print()

      for key, value in {name: "Tom", age: 30} {
          print(key, value)
      }

    output:
    - "a"
    - "b"
    - "c"

    - "0 a"
    - "1 b"
    - "2 c"

    - "0 a"
    - "1 b"
    - "2 c"

    - "age 30"
    - "name Tom"
  - name: Permissions
    id: perm-basics
    program: |
      # In Inox some operations require permissions: reading a file, sending an HTTP request, 
      # or creating a lightweight thread. The permissions of a module are specified in its manifest.
      manifest {
          permissions: {
              read: {
                  # allow reading any file in the /dir/ directory
                  %/... 

                  # allow making HTTPS GET requests to example.com
                  https://example.com
              }
          }
      }
      print(http.read!(https://example.com/), "\n")

      print("entries of /:", fs.ls!(/))
- name: Filesystem
  id: filesystem

  tutorials:
  - name: Files
    id: file-basics
    program: |
      const (
          PATH = /temp_file.txt
      )

      # accessing the filesystem requires specifying some permissions in the manifest.
      manifest {
          permissions: {
              read: PATH    # allow reading the content of /temp_file.txt
              write: PATH   # allow creating and writing /temp_file.txt
              delete: PATH  # allow removing /temp_file.txt
          }
      }

      # remove the file /temp_file.txt.
      fs.rm!(PATH)

      # create /temp_file.txt and write `hello` in it.
      fs.mkfile!(PATH, "hello")

      # read the content of the file.
      print("content:", fs.read!(PATH))

      # learn more by hovering the called functions.

    output:
    - "content: hello"

  - name: Directories
    id: dir-basics
    program: |
      const (
          # directory paths always end with a slash.
          DIR_PATH = /temp_dir/
      )

      manifest {
          permissions: {
              read: %/temp_dir/...    # allow reading any file inside /temp_dir/.
              write: %/temp_dir/...   # allow creating /temp_dir/ and creating + writing any file in it.
              delete: %/temp_dir/...  # allow removing /temp_dir/ and any file in it.
          }
      }

      # remove /temp_dir/ if it exists.
      fs.rm!(DIR_PATH)

      # create /temp_dir/
      fs.mkdir!(DIR_PATH)

      # create /temp_dir/file.txt
      fs.mkfile!(DIR_PATH.join(./file.txt), "content")

      # read the entries of the directory.
      print("entries:", fs.ls!(DIR_PATH))

      # learn more by hovering the called functions.
      
# ------------------------------------------------------------


