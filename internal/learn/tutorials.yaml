# tutorial series

- name: Basics  
  id: basics
  description: >
    Learn the basics of Inox in a few tutorials !
  
  tutorials:
  - name: Hello World
    id: hello-world
    program: |
      # Inox modules always start with a manifest.
      manifest { }
      
      print("Hello World!")
    output: 
    - Hello World!
  - name: Variables
    id: var-basics
    program: |
      manifest {}
      
      # There are two kinds of variables: globals & locals.
      # Local variables are declared with the `var` keyword or with an assignment.
      var local1 = 1
      
      # Assigning a local that is not declared is equivalent to declaring it.
      local2 = 2
      
      # Variable declarations can have a type annotation.
      # Replace `0` with `str` to see what happens.
      var i int = 0

      # Global variable declaration
      globalvar global1 = 1

      # Assigning a global that is not declared is equivalent to declaring it.
      $$global2 = 2
      
      # Global variables cannot be shadowed by local variables.
      # var global1 = 3

      print("local1 =", local1, "global1 =", global1)
    output:
    - "local1 = 1 global1 = 1"

  - name: Functions
    id: func-basics
    program: |
      manifest {}
      
      # Native (Golang) functions are built-in and cannot be defined.
      print("print is a native function")

      # Inox Functions are declared at the top-level of the module.
      fn hello(arg){
          print("hello", arg)
          return 0
      }

      # Parameters and return value of a function can have a type annotation:
      fn add(a int, b int) int {
          return (a + b)
      }

      # Parenthesized call
      print("add(1, 2) =", add(1, 2))

      pattern user = {
          name: str
          friends: []str
      }

      fn new_user(data {name: str}) user {
          return {
              name: data.name
              friends: []
          }
      }

      # Shorthand call syntax for functions accepting a single argument of type object.
      user = new_user{name: "Tom"}
    output:
    - "print is a native function"
    - "add(1, 2) = 3"

  - name: "'Must' Calls"
    id: must-call-basics
    program: |
      manifest {}

      # 'must' calls are special calls that cause a panic if there is an error. 
      # If there is no error the returned value is transformed.

      # the unhex function decodes an hexadecimal strig.
      # normal call: a value of type Array(byte-slice, (error | nil)) is returned.
      assign bytes error = unhex("...")

      print("decoding error:", error)

      # must call: a value of type byte-slice is returned if there is no error.
      # bytes = unhex!("...")

      fn f(issue bool) (| error | nil) {
          if issue {
              return Error("there is an issue !")
          }
          return nil
      }

      # normal call: a value of type (error | nil) is returned.
      err = f(true)

      print("error returned by `f`:", err)

      # must call: on error the runtime panics, otherwise nil is returned.
      nil_value = f!(false)      

      # you can learn more about must calls here: https://github.com/inoxlang/inox/blob/master/docs/language-reference.md#must-calls.
    output:
    - "decoding error: (hex.InvalidByteError)encoding/hex: invalid byte: U+002E '.'"
    - "error returned by `f`: (*errors.errorString)there is an issue !"

  - name: Binary Expressions
    id: bin-expr-basics
    program: |
      manifest {}

      # Binary operations are always parenthesized:

      int = (1 + 2)
      float = (1.0 + (5.0 + 2.0))
      range1 = (0 .. 2)   # inclusive end
      range2 = (0 ..< 3)  # exclusive end

      # Parentheses can be omitted around operands of or/and chains:

      a = true; b = false; c = true
      n = 0; p = 2

      (a or b or c)      
      (n < 1 or p < 3)

      # 'or' and 'and' cannot be mixed in the same chain
      # (a or b and c)     

    output: []


  - name: If, Switch, Match
    id: if-switch-match-basics
    program: |
      manifest {}

      a = 0

      # if statement
      if (a == 0) {
          print("a == 0")
      } else {
          print("a != 0")
      }

      # if expression
      zero = (if (a == 0) 0 else 1)

      b = 1

      # switch statement
      switch b {
          0 {
              print("b == 0")
          }
          1 {
              print("b == 1")
          }
          defaultcase {
              print("b != 0 and b != 1")
          }
      }

      # The match statement is similar to the switch statement but uses patterns as case values. 
      # It executes the block following the first pattern matching the value.

      c = 2

      match c {
          %int(0..2) {
              print "c is in the range 0..2"
          }
          %int {
              print "c is an integer"
          }
          defaultcase { 
              print "c is not an integer"
          }
      }
    output:
    - "a == 0"
    - "b == 1"
    - "c is in the range 0..2"

  - name: For statement
    id: for-stmt-basics
    program: |
      manifest {}

      list = ["a", "b", "c"]

      for elem in list {
          print(elem)
      }

      print()

      for index, elem in list {
          print(index, elem)
      }

      print()

      for i in (0 ..< len(list)) {
          print(i, list[i])
      }

      print()

      for key, value in {name: "Tom", age: 30} {
          print(key, value)
      }

    output:
    - "a"
    - "b"
    - "c"

    - "0 a"
    - "1 b"
    - "2 c"

    - "0 a"
    - "1 b"
    - "2 c"

    - "age 30"
    - "name Tom"
  - name: Objects
    id: objects
    program: |
        manifest {}

        # An object is a data structure containing properties, each property has a name and a value.
        object1 = {  
            a: 1
            "b": 2
            c: 0, d: 100ms
        }

        a = object1.a
        print("a:", a)

        # Implicit-key properties are properties that can be set without specifying a name:
        object2 = {
            1
            []
        }

        print(object2)

        # Properties with an implicit key can be accessed thanks to an index expression,
        # the index should always be an integer.
        object3 = {1}
        print("object3[0]:", object3[0])
  - name: Lists
    id: lists
    program: |
        manifest {}

        # A list is a sequence of elements. You can add elements to it and change the
        # value of an element at a given position.

        list1 = []
        list1.append(1)

        first_elem = list1[0] # index expression
        list1[0] = 2

        list2 = [1, 2, 3]

        # the following slice expression creates a new list containing 1 and 2 
        print("list2[0:2]:", list2[0:2])
  - name: Paths and Path patterns
    id: paths-path-patterns
    program: |
        manifest {}

        # ====== paths ======

        absolute_filepath = /file.txt
        relative_filepath1 = ./file.txt
        relative_filepath2 = ../file.txt

        # directory paths end with a slash.
        absolute_dirpath = /dir/

        path = absolute_dirpath.join(./file.txt)
        print("(/dir/).join(./file.txt):", path)

        # if a path contains spaces or delimiters such as `[` or `]` it should be quoted:
        quoted_path = /`[file].txt`

        # ====== path patterns ======

        # prefix path patterns end with /...
        prefix_path_pattern = %/...

        print "\n(/ match %/...):" (/ match %/...)
        print "(/file.txt match %/...):" (/file.txt match %/...)
        print "(/dir/file.txt match %/...):" (/dir/file.txt match %/...)
        print "(/file.txt match %/dir/...):" (/file.txt match %/dir/...)

        # path patterns that do not end with /... are glob path patterns.
        glob_path_pattern = %/*.json

        print "\n(/ match %/*.json):" (/ match %/*.json)
        print "(/file.json match %/*.json):" (/file.json match %/*.json)
        print "(/dir/file.json match %/*.json):" (/dir/file.json match %/*.json)

        # You can learn more about path patterns in the language reference: 
        # https://github.com/inoxlang/inox/blob/master/docs/language-reference.md#path-patterns.
  - name: URLs and URLs patterns
    id: urls-url-patterns
    program: |
        manifest {}

        # ====== URLs and Hosts ======

        # host literals
        https_host = https://example.com
        websocket_host = wss://example.com
        schemeless_host = ://example.com

        # url literals
        url1 = https://example/
        url2 = https://example/index.html

        # ====== URL patterns ======

        # A URL pattern that ends with `/...` is a prefix URL pattern, it matches any URL that contains its prefix.

        print(
            "(https://example.com/ match %https://example.com/data/...):" 
            (https://example.com/ match %https://example.com/data/...)
        )

        print(
            "(https://example.com/data/ match %https://example.com/data/...):" 
            (https://example.com/data/ match %https://example.com/data/...)
        )

        print(
            "(https://example.com/data/file.json match %https://example.com/data/...):", 
            (https://example.com/data/file.json match %https://example.com/data/...)
        )

        # ====== Host patterns ======

        host_pattern = %http://**.com

        print(
            "\n(https://example.com match %https://**.com):" 
            (https://example.com match %https://**.com)
        )

        print(
            "(https://subdomain.example.com match %https://**.com):" 
            (https://subdomain.example.com match %https://**.com)
        )

        print(
            "(https://example.com match %https://*.example.com):" 
            (https://example.com match %https://*.example.com)
        )

        print(
            "(https://subdomain.example.com match %https://*.example.com):" 
            (https://subdomain.example.com match %https://*.example.com)
        )

        # You can learn more about URL patterns and host patterns in the language reference: 
        # https://github.com/inoxlang/inox/blob/master/docs/language-reference.md#host-and-url-patterns.

  - name: Named Patterns and Typing
    id: pattern-decl
    program: |
        manifest {}

        # In Inox a pattern is a runtime value that matches values of a given kind and shape.
        # Besides the pattern literals, there are other kinds of patterns in Inox such as object patterns: `%{a: int}`.
        # Even though patterns are created at runtime, they can act as types:

        pattern small_int = int(0..10)

        # small_int is created at runtime but it can be used in type annotations:
        var n small_int = 0

        fn add(a small_int, b small_int){
            return (a + b)
        }

        add(1, 2)

        # uncomment to see the error.
        # add(1, 2000)

        # Creating a named pattern `user` does not prevent you to name a variable `user`:
        pattern user = {
            name: str
        }

        user = {name: "foo"}

        # true
        (user match user)

        # alternative syntax
        (user match %user)
  - name: Object Patterns
    id: object-patterns
    program: |
        manifest {}

        # object pattern with a single property
        %{
            name: str
        }

        # same pattern stored in a named pattern ('%' not required)
        pattern object_pattern = {
            name: str
        }

        # ⚠️ By default object patterns are inexact: they accept additional properties.
        ({name: "John"} match {}) # true

        pattern user = {
            name: str
        }

        # true
        ({name: "John", additional_prop: 0} match user)
  - name:  List Patterns
    id: list-patterns
    program: |
        manifest {}

        # list pattern matching any list containing (only) integers.
        pattern int_list = []int

        print `([] match []int):` ([] match []int)
        print `([1] match []int):` ([1] match []int)
        print `([1, "a"] match []int):` ([1, "a"] match []int)

        # list pattern matching any list of length 2 having an integer as first element 
        # and a string-like value as second element.
        pattern pair = [int, str]

        print `\n([1, "a"] match [int, str]):` ([1, "a"] match [int, str])
  - name: Permissions
    id: perm-basics
    program: |
      # In Inox some operations require permissions: reading a file, sending an HTTP request, 
      # or creating a lightweight thread. The permissions of a module are specified in its manifest.
      manifest {
          permissions: {
              read: {
                  # allow reading any file in the /dir/ directory
                  %/... 

                  # allow making HTTPS GET requests to example.com
                  https://example.com
              }
          }
      }
      print(http.read!(https://example.com/), "\n")

      print("entries of /:", fs.ls!(/))

- name: Language Features Beyond Basics
  id: lang-features-beyond-basics

  tutorials:
  - name: Variadic Functions
    id: variadic-functions
    program: |
        manifest {}

        # Variadic functions are functions whose last parameter is a special type of parameter that can take any number of arguments. 
        # This is indicated by the '...' syntax. This parameter is named the variadic parameter and is always of type Array.

        fn return_variadic_arguments(first, ...rest){
            return rest
        }

        return_variadic_arguments(1)        # empty array 
        return_variadic_arguments(1, 2)     # Array(2)
        return_variadic_arguments(1, 2, 3)  # Array(2, 3)

        # The variadic parameter can have a type annotation:

        fn sum(...integers int){
            i = 0
            for int in integers {
                i += int
            }
            return i
        }

        print(sum())
        print(sum(1))
        print(sum(1, 2))

        # ...[2, 3] is a spread argument
        print(sum(1, ...[2, 3]))
- name: Filesystem
  id: filesystem

  tutorials:
  - name: Files
    id: file-basics
    program: |
      const (
          PATH = /temp_file.txt
      )

      # accessing the filesystem requires specifying some permissions in the manifest.
      manifest {
          permissions: {
              read: PATH    # allow reading the content of /temp_file.txt
              write: PATH   # allow creating and writing /temp_file.txt
              delete: PATH  # allow removing /temp_file.txt
          }
      }

      # remove the file /temp_file.txt.
      fs.rm!(PATH)

      # create /temp_file.txt and write `hello` in it.
      fs.mkfile!(PATH, "hello")

      # read the content of the file.
      print("content:", fs.read!(PATH))

      # learn more by hovering the called functions.
    output:
    - "content: hello"

  - name: Directories
    id: dir-basics
    program: |
      const (
          # directory paths always end with a slash.
          DIR_PATH = /temp_dir/


          # path patterns always start with the '%' symbol.
          DIR_PATH_PATTERN = %/temp_dir/...
      )

      manifest {
          permissions: {
              read: DIR_PATH_PATTERN    # allow reading any file inside /temp_dir/.
              write: DIR_PATH_PATTERN   # allow creating /temp_dir/ and creating + writing any file in it.
              delete: DIR_PATH_PATTERN  # allow removing /temp_dir/ and any file in it.
          }
      }

      # remove /temp_dir/ if it exists.
      fs.rm!(DIR_PATH)

      # create /temp_dir/
      fs.mkdir!(DIR_PATH)

      # create /temp_dir/file.txt
      fs.mkfile!(DIR_PATH.join(./file.txt), "content")

      # read the entries of the directory.
      print("entries:", fs.ls!(DIR_PATH))

      # learn more by hovering the called functions.
- name: HTTP Requests
  id: http-reqs

  tutorials:
  - name: GET Requests 1
    id: http-get-reqs
    program: |
      const (
          # host literal - note: adding a slash at the end would turn it into a URL literal.
          # This domain provides a mocked HTTP API.
          HOST = https://jsonplaceholder.typicode.com
      )

      # making HTTP operations requires specifying some permissions in the manifest.
      manifest {
          permissions: {
              # allow making GET and HEAD requests to HOST.
              read: HOST
          }
      }

      # create a host alias @host
      @host = HOST
      url = @host/posts/1

      assign resp err = http.get(url)
      if err? {
          print("err: ", err)
          return    
      }
      # note: if you don't want to handle the error you can use a 'must' call instead.
      # See the corresponding tutorial in the Basics series.

      print(resp)

      # read all the body and print it.
      raw_content = resp.body.read_all!()
      print("raw content: ", tostr(raw_content))

      # the next tutorial show how to use a more convenient function: http.read.
  - name: GET Requests 2 (http.read)
    id: http-get-reqs2
    program: |
      const (
          HOST = https://jsonplaceholder.typicode.com
      )

      manifest {
          permissions: {
              read: HOST
          }
      }

      @host = HOST

      # The http.read function directly reads and parses the body.
      # By default the type of content is determined by looking at the Content-Type header.

      parsed_json = http.read!(@host/posts/1)
      print("value:", parsed_json)

      # You can specify a content type by adding a mimetype value.

      text = http.read!(@host/posts/1, mime"text")
      print("text:", text)
  - name: POST & PATCH Requests
    id: http-post-patch-reqs
    program: |
        const (
            USERS_ENDPOINT = https://jsonplaceholder.typicode.com/users
            USER1_ENDPOINT = https://jsonplaceholder.typicode.com/users/1
        )

        # note: https://jsonplaceholder.typicode.com provides a mocked API,
        # the requests we make further in the code have no real effects.

        manifest {
            permissions: {
                # allow making POST and PATCH requests to the specified endpoints.
                write: {
                    USERS_ENDPOINT
                    USER1_ENDPOINT
                }
            }
        }

        # make a POST request to create a new user.
        resp1 = http.post!(USERS_ENDPOINT, {
            name: "John Doe",
            username: "JohnD",
            email: "john.doe@example.com"
        })

        body = tostr(resp1.body.read_all!())
        print("first response's body:", body)


        # make a PATCH request to update a user.
        resp2 = http.patch!(USER1_ENDPOINT, {
            title: "New title",
        })

        print("second response:", resp2)
  - name: DELETE Requests
    id: http-delete-reqs
    program: |
        const (
            USER1_ENDPOINT = https://jsonplaceholder.typicode.com/users/1
        )

        # note: https://jsonplaceholder.typicode.com provides a mocked API,
        # the requests we make further in the code have no real effects.

        manifest {
            permissions: {
                # allow making DELETE requests to the specified endpoint.
                delete: USER1_ENDPOINT
            }
        }

        # make a DELETE request to delete the user of id 1
        resp = http.delete!(USER1_ENDPOINT)

        print(resp)
- name: Concurrency
  id: concurrency

  tutorials:
  - name: Lightweight Threads
    id: lthread-basics
    program: |
        # LThreads (lightweight threads) are mainly used for concurrent work and
        # isolation. Each lthread runs an Inox module in a dedicated Goroutine.

        const (
            USER1_ENDPOINT = https://jsonplaceholder.typicode.com/users/1
        )

        manifest {
            permissions: {
                create: {threads: {}}
                read: USER1_ENDPOINT
            }
        }

        # There are several ways to create a lightweight thread with a spawn expression.
        # If you only want to call a function without passing variables as arguments you can use the following:

        # the idt function returns its argument.
        lthread1 = go do idt(1) 
        print("lthread1's result:", lthread1.wait_result!())


        # If you need to pass the value of a variable as argument you can define the lthread's globals.
        # Predefined globals (print, read, write, http, fs, ...) are always inherited,
        # you don't need to add them to the globals section.

        var a = "a"
        lthread2 = go {globals: {a: a}} do idt(a)
        print("lthread2's result:", lthread2.wait_result!())



        # If you want to write custom logic for the lthread you can replace the function 
        # call by an embedded module:
        var operand1 = 1
        var operand2 = 2

        lthread3 = go {globals: {operand1: operand1, operand2: operand2}} do {
            # embedded module

            return (operand1 + operand2)
        }
        print("lthread3's result:", lthread3.wait_result!())


        # Data sharing follows specific rules that are explained in details in a turorial in this series.
  - name: Permissions
    id: lthread-perms
    program: |
        manifest {
            permissions: {
                create: {threads: {}}
                read: %/...
            }
        }

        # Lthreads created by spawn expressions inherit almost all of the permissions of
        # the parent module by default. The thread creation permission is removed.
        # You can specify what permissions are granted in the allow section of the meta value.

        # create a lthread with no permissions.
        thread1 = go {
            allow: {}
        } do {
            # A read permission is missing.
            # If an error is shown by the debugger on the following line, press the arrow to continue.
            return fs.ls!(/)
        }

        assign result err = thread1.wait_result()
        print("err:", err)

        # create a lthread allowed to read any file and directory.
        thread2 = go {
            allow: { read: %/... }
        } do {
            return fs.ls!(/)
        }

        print("entries:", thread2.wait_result!())
  - name: LThread Group
    id: lthread-groups
    program: |
        # LThread Groups allow easier control of multiple lthreads.

        const (
            USERS_PREFIX_PATTERN = %https://jsonplaceholder.typicode.com/users/...
        )

        manifest {
            permissions: {
                create: {threads: {}}
                read: USERS_PREFIX_PATTERN
            }
        }

        req_group = LThreadGroup()

        thread_fetching_user1_data = go {group: req_group} do read!(https://jsonplaceholder.typicode.com/users/1)
        thread_fetching_user2_data = go {group: req_group} do read!(https://jsonplaceholder.typicode.com/users/2)

        results = req_group.wait_results!()
        print("users:", results)
  - name: Data sharing
    id: lthread-data-sharing
    program: |
        manifest {
            permissions: {
                create: {threads: {}}
            }
        }

        # Immutable and lock-protected values are sharable between threads.
        
        # The most common immutables values are records, tuples, string-like values
        # and all simple values ( floats, integral values (ints, bytes, ...)
        immutable = #{a: 1}
        
        # The most common lock-protected values are objects.
        lock_protected = {b: 2}

        lthread = go {
            globals: {
                record: immutable
                object: lock_protected
            }
        } do {
            # assigning a property of a lock-protected value causes the underlying lock of the object to be acquired
            # before the mutation and to be released afterwards.
            
            object.b = 3
        }

        lthread.wait_result!()
        print("object =", lock_protected)

        # Non-sharable values that are clonable are cloned when passed to another execution context.
        clonable = [1, 2, 3]

        go {globals: {list: clonable}} do {
            # since the value is cloned mutating the list has no impact on the variable `clonable`.
            list.append(4)
        }
- name: Imports
  id: imports

  tutorials:
  - name: Inclusion Imports
    id: incl-imports
    program: |
        manifest {}
      
        # An inclusion import includes the content of a file in the current module.
        # Inclusion imports are useful to decompose a module or regroup pattern definitions 
        # and functions shared between modules.
        # In order to be includable a file should start with the `includable-chunk` keyword:

        import /tutorial-files/schema.ix

        print("CONST_FROM_FILE:", CONST_FROM_FILE)
        print("pattern from the included file:", %user)
        
        function_from_file()
    other-files: 
        /tutorial-files/schema.ix: |
            # In order to be includable a file should start with the following keyword.
            includable-chunk

            const (
                CONST_FROM_FILE = 1
            )

            fn function_from_file(){
                print("hello from included file")
            }

            pattern user = {
                name: str
            }
  - name: Module Imports
    id: module-imports
    program: |
        manifest {
            permissions: {
                read: %/...    # don't forget the read permission
            }
        }

        # A module import imports a module: an Inox file that starts with a manifest.
        # ⚠️ Each module import creates a new instance of the imported module.
        import result ./tutorial-files/return_1.ix {}

        print(result) 
    other-files: 
        /tutorial-files/return_1.ix: |
            manifest {}

            return 1
  - name: Arguments
    id: module-imports-with-args
    program: |
        manifest {
            permissions: {
                read: %/...    # don't forget the read permission
            }
        }

        # Importing a module
        import result ./tutorial-files/add.ix {
            # import configuration

            arguments: {1, 2}
        } 

        print(result)
    other-files: 
        /tutorial-files/add.ix: |
            manifest {
                parameters: {
                    {
                        name: #first_operand
                        pattern: %int
                    }
                    {
                        name: #second_operand
                        pattern: %int
                    }
                }
            }

            # the module arguments are stored in the `mod-args` variable.

            return (mod-args.first_operand + mod-args.second_operand)
- name: Database
  id: database

  tutorials:
  - name: Database Definition
    id: db-definition
    program: |
        # Inox comes with an embedded database engine.
        # Databases are defined in the manifest:

        manifest {
            permissions: {
                read: %/tutorial-files/databases/main0/...
                write: %/tutorial-files/databases/main0/...
            }

            databases: {
                # define a local database named 'main0' that persists data in /tutorial-files/databases/main0/.
                main0: {
                    resource: ldb://main0
                    resolution-data: /tutorial-files/databases/main0/
                }
            }
        }

        # the `dbs` global variable holds references to the defined databases.
        db = dbs.main0
        print("schema:", db.schema)
  - name: Database Schema
    id: db-schema
    program: |
        # Inox comes with an embedded database engine.
        # Databases are defined in the manifest:

        manifest {
            permissions: {
                read: %/tutorial-files/databases/main1/...
                write: %/tutorial-files/databases/main1/...
            }

            databases: {
                # define a local database named 'main1' that persists data in /tutorial-files/databases/main1/.
                main1: {
                    resource: ldb://main1
                    resolution-data: /tutorial-files/databases/main1/

                    expected-schema-update: true
                }
            }
        }

        # The schema of an Inox Database is an object pattern and can
        # be set by calling the `update_schema` method on the database.
        # ⚠️ Calling `update_schema` requires the following property in the database description: `expected-schema-update: true`.

        db = dbs.main1

        pattern user = {
            name: str
        }

        print("schema before update:", db.schema)

        db.update_schema(%{
            users: Set(user, #url)
        }, {
            inclusions: :{
                %/users: []
            }
        })

        print("schema after update:", db.schema)
# ------------------------------------------------------------