# tutorial series

- name: Basics  
  id: basics
  description: >
    Learn the basics of Inox in a few tutorials !
  
  tutorials:
  - name: Hello World
    id: hello-world
    program: |
      # Inox modules always start with a manifest.
      manifest { }
      
      print("Hello World!")
    output: 
    - Hello World!
  - name: Variables
    id: var-basics
    program: |
      manifest {}
      
      # There are two kinds of variables: globals & locals.
      # Local variables are declared with the `var` keyword or with an assignment.
      var local1 = 1
      
      # Assigning a local that is not declared is equivalent to declaring it.
      local2 = 2
      
      # Variable declarations can have a type annotation.
      # Replace `0` with `str` to see what happens.
      var i int = 0

      # Global variable declaration
      globalvar global1 = 1

      # Assigning a global that is not declared is equivalent to declaring it.
      $$global2 = 2
      
      # Global variables cannot be shadowed by local variables.
      # var global1 = 3

      print("local1 =", local1, "global1 =", global1)
    output:
    - "local1 = 1 global1 = 1"

  - name: Functions
    id: func-basics
    program: |
      manifest {}
      
      # Native (Golang) functions are built-in and cannot be defined.
      print("print is a native function")

      # Inox Functions are declared at the top-level of the module.
      fn hello(arg){
          print("hello", arg)
          return 0
      }

      # Parameters and return value of a function can have a type annotation:
      fn add(a int, b int) int {
          return (a + b)
      }

      # Parenthesized call
      print("add(1, 2) =", add(1, 2))

      pattern user = {
        name: str
        friends: []str
      }

      fn new_user(data {name: str}) user {
        return {
          name: data.name
          friends: []
        }
      }

      # Shorthand call syntax for functions accepting a single argument of type object.
      user = new_user{name: "Tom"}
    output:
    - "print is a native function"
    - "add(1, 2) = 3"

  - name: "'Must' calls"
    id: inox-func-basics
    program: |
      manifest {}

      # 'must' calls are special calls that cause a panic if there is an error. 
      # If there is no error the returned value is transformed.

      # the unhex function decodes an hexadecimal strig.
      # normal call: a value of type Array(byte-slice, (error | nil)) is returned.
      assign bytes error = unhex("...")

      print("decoding error:", error)

      # must call: a value of type byte-slice is returned if there is no error.
      # bytes = unhex!("...")

      fn f(issue bool) (| error | nil) {
          if issue {
              return Error("there is an issue !")
          }
          return nil
      }

      # normal call: a value of type (error | nil) is returned.
      err = f(true)

      print("error returned by `f`:", err)

      # must call: on error the runtime panics, otherwise nil is returned.
      nil_value = f!(false)      

      # you can learn more about must calls here: https://github.com/inoxlang/inox/blob/master/docs/language-reference.md#must-calls.
    output:
    - "decoding error: (hex.InvalidByteError)encoding/hex: invalid byte: U+002E '.'"
    - "error returned by `f`: (*errors.errorString)there is an issue !"
# ------------------------------------------------------------


