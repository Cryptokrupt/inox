# tutorial series

- name: Basics  
  id: basics
  description: >
    Learn the basics of Inox in a few tutorials !
  
  tutorials:
  - name: Hello World
    id: hello-world
    program: |
      # Inox modules always start with a manifest.
      manifest { }
      
      print("Hello World!")
    output: 
    - Hello World!
  - name: Variables
    id: var-basics
    program: |
      manifest {}
      
      # There are two kinds of variables: globals & locals.
      # Local variables are declared with the `var` keyword or with an assignment.
      var local1 = 1
      
      # Assigning a local that is not declared is equivalent to declaring it.
      local2 = 2
      
      # Variable declarations can have a type annotation.
      # Replace `0` with `str` to see what happens.
      var i int = 0

      # Global variable declaration
      globalvar global1 = 1

      # Assigning a global that is not declared is equivalent to declaring it.
      $$global2 = 2
      
      # Global variables cannot be shadowed by local variables.
      # var global1 = 3

      print("local1 =", local1, "global1 =", global1)
    output:
    - "local1 = 1 global1 = 1"

  - name: Functions
    id: func-basics
    program: |
      manifest {}
      
      # Native (Golang) functions are built-in and cannot be defined.
      print("print is a native function")

      # Inox Functions are declared at the top-level of the module.
      fn hello(arg){
          print("hello", arg)
          return 0
      }

      # Parameters and return value of a function can have a type annotation:
      fn add(a int, b int) int {
          return (a + b)
      }

      # Parenthesized call
      print("add(1, 2) =", add(1, 2))

      pattern user = {
          name: str
          friends: []str
      }

      fn new_user(data {name: str}) user {
          return {
              name: data.name
              friends: []
          }
      }

      # Shorthand call syntax for functions accepting a single argument of type object.
      user = new_user{name: "Tom"}
    output:
    - "print is a native function"
    - "add(1, 2) = 3"

  - name: "'Must' calls"
    id: must-call-basics
    program: |
      manifest {}

      # 'must' calls are special calls that cause a panic if there is an error. 
      # If there is no error the returned value is transformed.

      # the unhex function decodes an hexadecimal strig.
      # normal call: a value of type Array(byte-slice, (error | nil)) is returned.
      assign bytes error = unhex("...")

      print("decoding error:", error)

      # must call: a value of type byte-slice is returned if there is no error.
      # bytes = unhex!("...")

      fn f(issue bool) (| error | nil) {
          if issue {
              return Error("there is an issue !")
          }
          return nil
      }

      # normal call: a value of type (error | nil) is returned.
      err = f(true)

      print("error returned by `f`:", err)

      # must call: on error the runtime panics, otherwise nil is returned.
      nil_value = f!(false)      

      # you can learn more about must calls here: https://github.com/inoxlang/inox/blob/master/docs/language-reference.md#must-calls.
    output:
    - "decoding error: (hex.InvalidByteError)encoding/hex: invalid byte: U+002E '.'"
    - "error returned by `f`: (*errors.errorString)there is an issue !"

  - name: Binary expressions
    id: bin-expr-basics
    program: |
      manifest {}

      # Binary operations are always parenthesized:

      int = (1 + 2)
      float = (1.0 + (5.0 + 2.0))
      range1 = (0 .. 2)   # inclusive end
      range2 = (0 ..< 3)  # exclusive end

      # Parentheses can be omitted around operands of or/and chains:

      a = true; b = false; c = true
      n = 0; p = 2

      (a or b or c)      
      (n < 1 or p < 3)

      # 'or' and 'and' cannot be mixed in the same chain
      # (a or b and c)     

    output: []


  - name: If, Switch, Match
    id: if-switch-match-basics
    program: |
      manifest {}

      a = 0

      # if statement
      if (a == 0) {
          print("a == 0")
      } else {
          print("a != 0")
      }

      # if expression
      zero = (if (a == 0) 0 else 1)

      b = 1

      # switch statement
      switch b {
          0 {
              print("b == 0")
          }
          1 {
              print("b == 1")
          }
          defaultcase {
              print("b != 0 and b != 1")
          }
      }

      # The match statement is similar to the switch statement but uses patterns as case values. 
      # It executes the block following the first pattern matching the value.

      c = 2

      match c {
          %int(0..2) {
              print "c is in the range 0..2"
          }
          %int {
              print "c is an integer"
          }
          defaultcase { 
              print "c is not an integer"
          }
      }
    output:
    - "a == 0"
    - "b == 1"
    - "c is in the range 0..2"

  - name: For statement
    id: for-stmt-basics
    program: |
      manifest {}

      list = ["a", "b", "c"]

      for elem in list {
          print(elem)
      }

      print()

      for index, elem in list {
          print(index, elem)
      }

      print()

      for i in (0 ..< len(list)) {
          print(i, list[i])
      }

      print()

      for key, value in {name: "Tom", age: 30} {
          print(key, value)
      }

    output:
    - "a"
    - "b"
    - "c"

    - "0 a"
    - "1 b"
    - "2 c"

    - "0 a"
    - "1 b"
    - "2 c"

    - "age 30"
    - "name Tom"
  - name: Permissions
    id: perm-basics
    program: |
      # In Inox some operations require permissions: reading a file, sending an HTTP request, 
      # or creating a lightweight thread. The permissions of a module are specified in its manifest.
      manifest {
          permissions: {
              read: {
                  # allow reading any file in the /dir/ directory
                  %/... 

                  # allow making HTTPS GET requests to example.com
                  https://example.com
              }
          }
      }
      print(http.read!(https://example.com/), "\n")

      print("entries of /:", fs.ls!(/))
- name: Filesystem
  id: filesystem

  tutorials:
  - name: Files
    id: file-basics
    program: |
      const (
          PATH = /temp_file.txt
      )

      # accessing the filesystem requires specifying some permissions in the manifest.
      manifest {
          permissions: {
              read: PATH    # allow reading the content of /temp_file.txt
              write: PATH   # allow creating and writing /temp_file.txt
              delete: PATH  # allow removing /temp_file.txt
          }
      }

      # remove the file /temp_file.txt.
      fs.rm!(PATH)

      # create /temp_file.txt and write `hello` in it.
      fs.mkfile!(PATH, "hello")

      # read the content of the file.
      print("content:", fs.read!(PATH))

      # learn more by hovering the called functions.
    output:
    - "content: hello"

  - name: Directories
    id: dir-basics
    program: |
      const (
          # directory paths always end with a slash.
          DIR_PATH = /temp_dir/


          # path patterns always start with the '%' symbol.
          DIR_PATH_PATTERN = %/temp_dir/...
      )

      manifest {
          permissions: {
              read: DIR_PATH_PATTERN    # allow reading any file inside /temp_dir/.
              write: DIR_PATH_PATTERN   # allow creating /temp_dir/ and creating + writing any file in it.
              delete: DIR_PATH_PATTERN  # allow removing /temp_dir/ and any file in it.
          }
      }

      # remove /temp_dir/ if it exists.
      fs.rm!(DIR_PATH)

      # create /temp_dir/
      fs.mkdir!(DIR_PATH)

      # create /temp_dir/file.txt
      fs.mkfile!(DIR_PATH.join(./file.txt), "content")

      # read the entries of the directory.
      print("entries:", fs.ls!(DIR_PATH))

      # learn more by hovering the called functions.
- name: HTTP Requests
  id: http-reqs

  tutorials:
  - name: GET Requests 1
    id: http-get-reqs
    program: |
      const (
          # host literal - note: adding a slash at the end would turn it into a URL literal.
          # This domain provides a mocked HTTP API.
          HOST = https://jsonplaceholder.typicode.com
      )

      # making HTTP operations requires specifying some permissions in the manifest.
      manifest {
          permissions: {
              # allow making GET and HEAD requests to HOST.
              read: HOST
          }
      }

      # create a host alias @host
      @host = HOST
      url = @host/posts/1

      assign resp err = http.get(url)
      if err? {
          print("err: ", err)
          return    
      }
      # note: if you don't want to handle the error you can use a 'must' call instead.
      # See the corresponding tutorial in the Basics series.

      print(resp)

      # read all the body and print it.
      raw_content = resp.body.read_all!()
      print("raw content: ", tostr(raw_content))

      # the next tutorial show how to use a more convenient function: http.read.
  - name: GET Requests 2 (http.read)
    id: http-get-reqs2
    program: |
      const (
          HOST = https://jsonplaceholder.typicode.com
      )

      manifest {
          permissions: {
              read: HOST
          }
      }

      @host = HOST

      # The http.read function directly reads and parses the body.
      # By default the type of content is determined by looking at the Content-Type header.

      parsed_json = http.read!(@host/posts/1)
      print("value:", parsed_json)

      # You can specify a content type by adding a mimetype value.

      text = http.read!(@host/posts/1, mime"text")
      print("text:", text)
  - name: POST & PATCH Requests
    id: http-post-patch-reqs
    program: |
        const (
            USERS_ENDPOINT = https://jsonplaceholder.typicode.com/users
            USER1_ENDPOINT = https://jsonplaceholder.typicode.com/users/1
        )

        # note: https://jsonplaceholder.typicode.com provides a mocked API,
        # the requests we make further in the code have no real effects.

        manifest {
            permissions: {
                # allow making POST and PATCH requests to the specified endpoints.
                write: {
                    USERS_ENDPOINT
                    USER1_ENDPOINT
                }
            }
        }

        # make a POST request to create a new user.
        resp1 = http.post!(USERS_ENDPOINT, {
            name: "John Doe",
            username: "JohnD",
            email: "john.doe@example.com"
        })

        body = tostr(resp1.body.read_all!())
        print("first response's body:", body)


        # make a PATCH request to update a user.
        resp2 = http.patch!(USER1_ENDPOINT, {
            title: "New title",
        })

        print("second response:", resp2)
  - name: DELETE Requests
    id: http-delete-reqs
    program: |
        const (
            USER1_ENDPOINT = https://jsonplaceholder.typicode.com/users/1
        )

        # note: https://jsonplaceholder.typicode.com provides a mocked API,
        # the requests we make further in the code have no real effects.

        manifest {
            permissions: {
                # allow making DELETE requests to the specified endpoint.
                delete: USER1_ENDPOINT
            }
        }

        # make a DELETE request to delete the user of id 1
        resp = http.delete!(USER1_ENDPOINT)

        print(resp)
- name: Concurrency
  id: concurrency

  tutorials:
  - name: Lightweight Threads
    id: lthread-basics
    program: |
        # LThreads (lightweight threads) are mainly used for concurrent work and
        # isolation. Each lthread runs an Inox module in a dedicated Goroutine.

        const (
            USER1_ENDPOINT = https://jsonplaceholder.typicode.com/users/1
        )

        manifest {
            permissions: {
                create: {threads: {}}
                read: USER1_ENDPOINT
            }
        }

        # There are several ways to create a lightweight thread with a spawn expression.
        # If you only want to call a function without passing variables as arguments you can use the following:

        # the idt function returns its argument.
        lthread1 = go do idt(1) 
        print("lthread1's result:", lthread1.wait_result!())


        # If you need to pass the value of a variable as argument you can define the lthread's globals.
        # Predefined globals (print, read, write, http, fs, ...) are always inherited,
        # you don't need to add them to the globals section.

        var a = "a"
        lthread2 = go {globals: {a: a}} do idt(a)
        print("lthread2's result:", lthread2.wait_result!())



        # If you want to write custom logic for the lthread you can replace the function 
        # call by an embedded module:
        var operand1 = 1
        var operand2 = 2

        lthread3 = go {globals: {operand1: operand1, operand2: operand2}} do {
            # embedded module

            return (operand1 + operand2)
        }
        print("lthread3's result:", lthread3.wait_result!())


        # Data sharing follows specific rules that are explained in details in a turorial in this series.
  - name: Permissions
    id: lthread-perms
    program: |
        manifest {
            permissions: {
                create: {threads: {}}
                read: %/...
            }
        }

        # Lthreads created by spawn expressions inherit almost all of the permissions of
        # the parent module by default. The thread creation permission is removed.
        # You can specify what permissions are granted in the allow section of the meta value.

        # create a lthread with no permissions.
        thread1 = go {
            allow: {}
        } do {
            # A read permission is missing.
            # If an error is shown by the debugger on the following line, press the arrow to continue.
            return fs.ls!(/)
        }

        assign result err = thread1.wait_result()
        print("err:", err)

        # create a lthread allowed to read any file and directory.
        thread2 = go {
            allow: { read: %/... }
        } do {
            return fs.ls!(/)
        }

        print("entries:", thread2.wait_result!())
  - name: LThread Group
    id: lthread-groups
    program: |
        # LThread Groups allow easier control of multiple lthreads.

        const (
            USERS_PREFIX_PATTERN = %https://jsonplaceholder.typicode.com/users/...
        )

        manifest {
            permissions: {
                create: {threads: {}}
                read: USERS_PREFIX_PATTERN
            }
        }

        req_group = LThreadGroup()

        thread_fetching_user1_data = go {group: req_group} do read!(https://jsonplaceholder.typicode.com/users/1)
        thread_fetching_user2_data = go {group: req_group} do read!(https://jsonplaceholder.typicode.com/users/2)

        results = req_group.wait_results!()
        print("users:", results)
  - name: Data sharing
    id: lthread-data-sharing
    program: |
        manifest {
            permissions: {
                create: {threads: {}}
            }
        }

        # Immutable and lock-protected values are sharable between threads.
        
        # The most common immutables values are records, tuples, string-like values
        # and all simple values ( floats, integral values (ints, bytes, ...)
        immutable = #{a: 1}
        
        # The most common lock-protected values are objects.
        lock_protected = {b: 2}

        lthread = go {
            globals: {
                record: immutable
                object: lock_protected
            }
        } do {
            # assigning a property of a lock-protected value causes the underlying lock of the object to be acquired
            # before the mutation and to be released afterwards.
            
            object.b = 3
        }

        lthread.wait_result!()
        print("object =", lock_protected)

        # Non-sharable values that are clonable are cloned when passed to another execution context.
        clonable = [1, 2, 3]

        go {globals: {list: clonable}} do {
            # since the value is cloned mutating the list has no impact on the variable `clonable`.
            list.append(4)
        }
- name: Imports
  id: imports

  tutorials:
  - name: Inclusion imports
    id: incl-imports
    program: |
        manifest {}
      
        # An inclusion import includes the content of a file in the current module.
        # Inclusion imports are useful to decompose a module or regroup pattern definitions 
        # and functions shared between modules.
        # In order to be includable a file should start with the `includable-chunk` keyword:

        import /tutorial-files/schema.ix

        print("CONST_FROM_FILE:", CONST_FROM_FILE)
        print("pattern from the included file:", %user)
        
        function_from_file()
    other-files: 
        /tutorial-files/schema.ix: |
            # In order to be includable a file should start with the following keyword.
            includable-chunk

            const (
                CONST_FROM_FILE = 1
            )

            fn function_from_file(){
                print("hello from included file")
            }

            pattern user = {
                name: str
            }
  - name: Module imports
    id: module-imports
    program: |
        manifest {
            permissions: {
                read: %/...    # don't forget the read permission
            }
        }

        # A module import imports a module: an Inox file that starts with a manifest.
        # ⚠️ Each module import creates a new instance of the imported module.
        import result ./tutorial-files/return_1.ix {}

        print(result) 
    other-files: 
        /tutorial-files/return_1.ix: |
            manifest {}

            return 1
  - name: Arguments
    id: module-imports-with-args
    program: |
        manifest {
            permissions: {
                read: %/...    # don't forget the read permission
            }
        }

        # Importing a module
        import result ./tutorial-files/add.ix {
            # import configuration

            arguments: {1, 2}
        } 

        print(result)
    other-files: 
        /tutorial-files/add.ix: |
            manifest {
                parameters: {
                    {
                        name: #first_operand
                        pattern: %int
                    }
                    {
                        name: #second_operand
                        pattern: %int
                    }
                }
            }

            # the module arguments are stored in the `mod-args` variable.

            return (mod-args.first_operand + mod-args.second_operand)
# ------------------------------------------------------------